## go module名称

模块由模块路径标识，模块路径就是模块的规范名称，如`github.com/bytedance/sonic`。很多时候模块名称加上https://前缀就是源码仓库的地址

模块名称在go.mod文件里，最初由go mod init ${module_name}命令指定，也可以手动修改



## go get

- **作用**：修改当前模块的依赖图（新增/升级/降级/移除），下载所需版本，更新 `go.mod` / `go.sum`。
- **顺序流程**：
  1. 定位 `go.mod`（确定当前模块）。
  2. 解析目标（包/模块路径与 `@版本`），包路径先映射到模块路径。
  3. 用 **MVS**（Minimal Version Selection）重新求解依赖版本集合（考虑 `replace/exclude/retract`）。
  4. 按 `GOPROXY`/`GOPRIVATE`/`GOVCS` 决定下载来源；按 `GOSUMDB` 校验哈希。
  5. 下载模块到 `$GOMODCACHE` 并校验；写/补 `go.sum`。
  6. 更新 `go.mod` 的 `require`（必要时标记 `// indirect`）。
  7. （建议）`go mod tidy` 清理未用依赖；使用 vendor 的项目再 `go mod vendor`。
- **与旧版区别**：
  - 早期 `go get` 会安装可执行文件；现在请用：`go install 包@版本`（不改依赖，只安装）。
- **常用观察/排错**：
  - 查看最终依赖：`go list -m -json all`
  - 依赖缘由：`go mod why -m 模块`
  - 校验问题清缓存：`go clean -modcache`
  - 私有仓库：`GOPRIVATE=your.corp/*`，必要时 `GOPROXY=direct`

一句话：**`go get` = 解析目标 → MVS 求解 → 通过代理/直连下载并校验 → 更新 `go.mod`/`go.sum` →（可选）tidy/vendor；不再装可执行文件。**

### go get子模块

go get gorm.io/gorm/logger会：

​	1.先发送GET请求https://gorm.io/gorm/logger?go-get=1，查不到源码地址

​	2.再回溯一级目录，请求https://gorm.io/gorm?go-get=1

### GOPROXY

go get并不是直接去源码仓库上下载代码，而是通过代理https://proxy.golang.org去下载，代理对源码镜像进行了缓存，并提供CDN加速。

国内代理：https://goproxycn和https://goproxy.io

自定义代理：`go env -w GOPROXY=https://goproxy.io`

go env -w不会写入环境变量，如果跟现有环境变量冲突则以环境变量为准

### 模块缓存

下载的模块会保存到环境变量GOMODCACHE指定的目录下，为所有go项目公用

GOMODCACHE的默认值为`$GOPATH/pkg/mod`也可以手动修改

模块路径和版本中的大写字母用感叹号转义，以避免在不区分大小写的文件系统中发生冲突

### GOSUMDB

`sum.golang.org`提供了一个`check sum database`，用来存储源代码的哈希值，以防止`go get`从任何源头拉取了被篡改的源码。

哈希值结果一致把模块存入本地缓存目录，并将哈希值存入`go.sum`文件，后续使用该模型时通过`go.sum`文件来校验。

设置`GOSUMDB=off`或者`go get` 时使用`-insecure`标志，表示不需要验证合法性。



## 使用私有go module

 在实际工作中，go module通常用来封装接口API，接口仅供公司内部调用，所以go module不能发布到公网



## 模块版本规范

版本格式：主版本号.次版本号.补丁号，递增规则如下：

​	主要版本在发布不兼容的公共接口更改后，例如模块里的某个包被删除，必须递增

​	次要版本号在发布向后兼容的更改后，例如添加新函数后，必须递增且补丁版本设置为0

​	补丁版本号在不修改到公共接口的情况下，例如bug修复或者做了一些优化，必须递增

go module每个版本以v开头，后面跟语义版本

​	没有语义版本时会生成一个伪版本